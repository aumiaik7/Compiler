#include "parser.h"

//constructor
Parser::Parser(ifstream &in, ofstream &out, Scanner &sc)
:srcFile(in),outFile(out),scanner(sc),islookAheadTok(false)
{
	
}

/*
  Imoplementation of the CFG is self explanatory
  for non terminal ther are corresponding methods
  and terminal symbols are matched using match(Symbol)
  method				
*/

// program = block '.'
void Parser::program(Symbol sym)
{
	

	
	lineNo = 1;	
	errorCount = 0;
	
	stopSet.push_back(sym);
	stopSet.push_back(DOT);
	
	
	//stops + newStops; 
	//newStops = st + DOT;
	//cout<<newStops[1]<<endl;
	outFile<<"program()"<<endl;	
	block(stopSet);	
	vector<Symbol>().swap(stopSet);
	
	match(DOT);
	
	//parsing done
	done();
		
}

// block = 'begin' definitionPart statementPart 'end'
void Parser::block(vector<Symbol> stops)
{
	outFile<<"block()"<<endl;
	match(BEGIN);
	
	lookAheadToken();
	if(in(ff.firstOfDefinition()))
	{	
		stopSet.clear();
		vector<Symbol>().swap(stopSet);
		stopSet.push_back(END);
		cout<<"Hmmmmph"<<endl;	
		definitionPart(ff.firstOfStatement() + stops + stopSet);
		cout<<"UHmmmmph"<<endl;
		statementPart(stops + stopSet);
		
	}
	else if(in(ff.followOfDefPart()))
	{
		cout<<"TUHmmmmph"<<endl;
		stopSet.clear();
		vector<Symbol>().swap(stopSet);
		stopSet.push_back(END);
		statementPart(stops + stopSet);
	}
	else
	{
		//error message
		cerr<<"Syntax Error: "<<"Illegal start of definition/statement at line "<< lineNo <<endl;
		ErrorCount();
	}

	//this portion matches end and if not matched the shows corresponding error message
	match(END);
}

// definitionPart = {definition';'}
void Parser::definitionPart(vector<Symbol> stops)
{
	
	outFile<<"definitionPart()"<<endl;
	
	lookAheadToken();
	
	if(in(ff.firstOfDefinition()))
	{
		outFile<<"Nothing"<<endl;
		stopSet.clear();
		vector<Symbol>().swap(stopSet);
		stopSet.push_back(SEMICOLON);	
		definition(stopSet + stops);
		match(SEMICOLON);
		definitionPart(stops);
	}
	else
	{
		outFile<<"Anyhing"<<endl;
	}
		
}

// definition = constantDefinition | variableDefinition | procedureDefinition
void Parser::definition(vector<Symbol> stops)
{
	outFile<<"definition()"<<endl;
	
	lookAheadToken();
	if(in(ff.firstOfConstDef()))
	{
		constantDefinition(stops);
	}
	else if(in(ff.firstOfVariDef()))
	{
		variableDefinition(stops);
	}
	else if(in(ff.firstOfProcDef()))
	{
		procedureDefinition(stops);
	}
}

// constantDefinition = 'const' constName '='  constant;
void Parser::constantDefinition(vector<Symbol> stops)
{
	outFile<<"constantDefinition()"<<endl;
	match(CONST);
	
	if(match(ID))
	{
		//id of type 2 is of constant type. if not matched the shows the corresponding error message 
		if(nextTok.getIDtype() != 2)
		{	
			//error message
			outFile<<"ID: "<<nextTok.getLexeme()<< " Type" << nextTok.getIDtype() <<endl;
			outFile<<"Syntax ErrorU: "<<"expecting name of constant type at line "<< lineNo <<endl;
			
		}
		
	}
	
		
	match(EQUAL);
	
	constant(stops);
	
}

// variableDefinition = typeSymbol variableList | typeSymbol 'array' variableList'['constant']'
void Parser::variableDefinition(vector<Symbol> stops)
{
	outFile<<"variableDefinition()"<<endl;	

	stopSet.clear();
	vector<Symbol>().swap(stopSet);
	stopSet.push_back(ARRAY);
	typeSymbol(stopSet + ff.firstOfVariList() + stops);
	lookAheadToken();
	if(in(ff.firstOfVariList()))
	{
		variableList(stops);
	}
	else if(match(ARRAY))
	{
		stopSet.clear();
		vector<Symbol>().swap(stopSet);
		stopSet.push_back(LEFTBRACKET);
		
		variableList(stopSet + stops);
		match(LEFTBRACKET);
		
		stopSet.clear();
		stopSet.push_back(RIGHTBRACKET);
					
		constant(stopSet + stops);
		match(RIGHTBRACKET);
	}
	
	
}

// procedureDefinition = 'proc' procedureName block
void Parser::procedureDefinition(vector<Symbol> stops)
{
	outFile<<"procedureDefinition()"<<endl;
	match(PROC);
	if(match(ID))
	{
		if(nextTok.getIDtype() != 3)
		{	
			//error message
			
		}
	}
	
	block(stops);
}

// typeSymbol = 'integer' | 'Boolean'
void Parser::typeSymbol(vector<Symbol> stops)
{
	outFile<<"typeSymbol()"<<endl;
	if(match(INT) || match(BOOL))
	{
		//do nothing		
	}
	
	
}

// variableList = variableName {','variableName}
void Parser::variableList(vector<Symbol> stops)
{
	outFile<<"variableList()"<<endl;
	//outFile<<"Matched" << nextTok.getSymbol()<<" Lexeme "<<nextTok.getLexeme()<<endl;
	if(match(ID))
	{
		if(nextTok.getIDtype() != 1)
		{	
				
		}
		
	}
	//lookAheadToken();
	if(match(COMMA))
	{
		variableList(stops);
	}
	
	
}

// statementPart = {statement';'}
void Parser::statementPart(vector<Symbol> stops)
{
	outFile<<"statementPart()"<<endl;
	lookAheadToken();
	if(in(ff.firstOfStatement()))
	{
		stopSet.clear();
		stopSet.push_back(SEMICOLON);
		
		statement(stopSet + stops);
		match(SEMICOLON);
		statementPart(stops);
	}
	else if(in(ff.followOfStatePart()))
	{
		//do nothing
	}
	
}

// statement = emptyStatement | readStatement | writeStatement |  assignmentStatement | ifStatement | doStatement 
void Parser::statement(vector<Symbol> stops)
{
	outFile<<"statement()"<<endl;
	lookAheadToken();	
	if(in(ff.firstOfEmptySt()))
	{
		match(SKIP);
	}
	else if(in(ff.firstOfReadSt()))
	{
		readStatement(stops);
	}
	else if(in(ff.firstOfWriteSt()))
	{
		writeStatement(stops);
	}
	else if(in(ff.firstOfProcSt()))
	{
		match(CALL);
		if(match(ID))
		{
			if(nextTok.getIDtype() != 3)
			{	
				//error message
					
			}
		}
		
	}
	else if(in(ff.firstOfAssignSt()))
	{
		assignmentStatement(stops);
	}
	else if(in(ff.firstOfIfSt()))
	{
		ifStatement(stops);		
	}
	else if(in(ff.firstOfDoSt()))
	{
		doStatement(stops);		
	}
	
}

// readStatement = 'read' variableAccessList
void Parser::readStatement(vector<Symbol> stops)
{
	outFile<<"readStatement()"<<endl;
	match(READ);
	variableAccessList(stops);
			
}

// variableAccessList = variableAccess{','variableAccess}
void Parser::variableAccessList(vector<Symbol> stops)
{
	outFile<<"variableAccessList()"<<endl;

	stopSet.clear();
	stopSet.push_back(COMMA);
	stopSet.push_back(ID);
	variableAccess(stopSet + stops);
	if(match(COMMA))
	{
		variableAccessList(stops);
	}
}

// writeStatement = 'write' expressionList  
void Parser::writeStatement(vector<Symbol> stops)
{
	outFile<<"writeStatement()"<<endl;
	match(WRITE);
	expressionList(stops);
}

// expressionList = expression {','expression}
void Parser::expressionList(vector<Symbol> stops)
{
	outFile<<"expressionList()"<<endl;
	
	stopSet.clear();
	stopSet.push_back(COMMA);

	expression(stopSet + stops);
	if(match(COMMA))
	{
		expressionList(stops);
	}
	
}

// assignmentStatement = variableAccessList ':=' expressionList
void Parser::assignmentStatement(vector<Symbol> stops)
{
	outFile<<"assignmentStatement()"<<endl;

	stopSet.clear();
	stopSet.push_back(ASSIGN);
	
	variableAccessList(stopSet + stops);
	match(ASSIGN);	
	expressionList(stops);
}

// ifStatement = 'if' guardedCommandList 'fi' 
void Parser::ifStatement(vector<Symbol> stops)
{
	outFile<<"ifStatement()"<<endl;
	match(IF);
	
	stopSet.clear();
	stopSet.push_back(FI);
	
	guardedCommandList(stopSet + stops);
	match(FI);	
}

// doStatement = 'do' guardedCommandList 'od'
void Parser::doStatement(vector<Symbol> stops)
{
	outFile<<"doStatement()"<<endl;
	match(DO);

	stopSet.clear();
	stopSet.push_back(OD);
	
	guardedCommandList(stopSet + stops);
	match(OD);
}

// guardedCommandList = guardedCommand{'[]'guardedCommand}
void Parser::guardedCommandList(vector<Symbol> stops)
{
	outFile<<"guardedCommandList()"<<endl;

	stopSet.clear();
	stopSet.push_back(GC1);
	
	guardedCommand(stopSet + stops);
	lookAheadToken();
	if(nextTok.getSymbol() == GC1)
	{
		match(GC1);
		guardedCommandList(stops);
	}
	
}

// guardedCommand = expression '->' statementPart
void Parser::guardedCommand(vector<Symbol> stops)
{
	outFile<<"guardedCommand()"<<endl;
	
	stopSet.clear();
	stopSet.push_back(GC2);	
	
	expression(stopSet + ff.firstOfStatement() + stops);
	match(GC2);
	lookAheadToken();
	statementPart(stops);
}

// expression = primaryExpression{primaryOperator primaryExpression}	
void Parser::expression(vector<Symbol> stops)
{
	outFile<<"expression()"<<endl;	
	
	primaryExpression(ff.firstOfExpList() + ff.firstOfPrimOp() + stops);
	
	lookAheadToken();
	if(in(ff.firstOfPrimOp()))
	{
		primaryOperator(ff.firstOfExpList() + stops);
		expression(stops);
	}
}

// primaryOperator = '&' | '|'
void Parser::primaryOperator(vector<Symbol> stops)
{
	outFile<<"primaryOperator()"<<endl;
	if(match(AND) || match(OR))
	{
		
	}
}

// primaryExpression = simpleExpression [relationalOperator simpleExpression]
void Parser::primaryExpression(vector<Symbol> stops)
{
	outFile<<"primaryExpression()"<<endl;	
	simpleExpression(ff.firstOfRelOp() + stops);
	
	lookAheadToken();
	if(in(ff.firstOfRelOp()))
	{
		relationalOperator(stops);
		simpleExpression(stops);
	}
}	

// relationalOperator = '<' | '=' | '>'	
void Parser::relationalOperator(vector<Symbol> stops)
{
	outFile<<"relationalOperator()"<<endl;
	if(match(LESST) || match(EQUAL) || match(GREATERT) || match(LTE) || match(GTE))
	{
		
	}
}

// simpleExpression = ['-'] term {addingOperator term}
void Parser::simpleExpression(vector<Symbol> stops)
{
	outFile<<"simpleExpression()"<<endl;
	lookAheadToken();
	if(!in(ff.firstOfTerm()))
	{
		match(MINUS);	
	}
	term(ff.firstOfAddOp() + stops);
	lookAheadToken();	
	if(in(ff.firstOfAddOp()))
	{
		addopTerm(stops);
	}
	
}

// addingOperator = '+' | '-'
void Parser::addingOperator(vector<Symbol> stops)
{
	outFile<<"addingOperator()"<<endl;
	if(match(PLUS) || match(MINUS))
	{
		outFile<<"Ignore"<<endl;	
	}
	else
	{
		outFile<<"Error msg"<< endl;
	}
}

//helps to execute {addingOperator term}
void Parser::addopTerm(vector<Symbol> stops)
{
	lookAheadToken();
	if(in(ff.firstOfAddOp()))
	{
		addingOperator(stops);
		term(stops);
		addopTerm(stops);
	}
	
}

// term = factor {multiplyingOperator factor}
void Parser::term(vector<Symbol> stops)
{
	outFile<<"term()"<<endl;
	outFile<<"Call factor()"<<endl;
	factor(ff.firstOfMultOp() + stops);
	lookAheadToken();
	if(in(ff.firstOfMultOp()))
	{
		multiplyingOperator(stops);
		term(stops);
	}
}

// multiplyingOperator = '*' | '/' | '\'
void Parser::multiplyingOperator(vector<Symbol> stops)
{
	outFile<<"multiplyingOperator()"<<endl;
	if(match(TIMES) || match(DIV) || match(MOD))
	{
		
	}
	
}

//factor = constant | variableAccess | '('expression')' | '~' factor	
void Parser::factor(vector<Symbol> stops)
{
	outFile<<"factor()"<<endl;
	lookAheadToken();
	if(nextTok.getSymbol() == ID)
	{
		if(nextTok.getIDtype() == 1)
			variableAccess(stops);
		else if(nextTok.getIDtype() == 2)
			constant(stops);
	}
	else if(in(ff.firstOfConstant()))
	{
		constant(stops);	
	}
	/*else if(nextTok.getSymbol() == ID && nextTok.getIDtype() == 1)
	{
		variableAccess();	
	}
	*/
	else if(nextTok.getSymbol() == LEFTP)
	{
		match(LEFTP);

		stopSet.clear();
		stopSet.push_back(RIGHTP);
		
		expression(stopSet + stops);	
		match(RIGHTP);
	}
	else if(nextTok.getSymbol() == NOT)
	{
		match(NOT);
		factor(stops);	
	}
	else
	{
		cout<<"Kenu Kenu Kenu"<<endl;
	}
		
}

//variableAccess = variableName [indexSelector]
void Parser::variableAccess(vector<Symbol> stops)
{
	outFile<<"variableAccess()"<<endl;	
	if(match(ID))
	{
		if(nextTok.getIDtype() != 1)
		{	
			//error message
			
		}
	}
	
	lookAheadToken();
	if(in(ff.firstOfIndexSel()))
	{
		match(LEFTBRACKET);
		
		stopSet.clear();
		stopSet.push_back(RIGHTBRACKET);
		
		expression(stopSet + stops);	
		match(RIGHTBRACKET);
	}
}

// constanr = numeral | booleanSymbol | constantName
void Parser::constant(vector<Symbol> stops)
{
	outFile<<"constant()"<<endl;
	if(match(NUMERAL) || match(TRUE) || match(FALSE) || match(ID))
	{
		if(nextTok.getSymbol() == ID && nextTok.getIDtype() != 2)
		{
			
		}	
	}
	
	
}


//this function is used to match terminal symbols of CFG
bool Parser::match(Symbol sym)
{
	//look ahead token flag is disable is currently eanble and dont 
	//grab a new token as already grabbed using lookAheadToken() 
	//if(islookAheadTok)
//		islookAheadTok = false;
//	else	
//		nextTok = scanner.nextToken();

	//grab the token other than newline or noname
	if(nextTok.getSymbol() == NEWLINE || nextTok.getSymbol() == NONAME || nextTok.getSymbol() == EOF)
	{		
		
		while(1)
		{	
			//newline detected			
			if(nextTok.getSymbol() == NEWLINE)
			{
				NewLine();
			}
			else if(nextTok.getSymbol() != NONAME)
				break;
			nextTok = scanner.nextToken();
		}
		
	}
	
	//it means the token is matched returns true
	if(nextTok.getSymbol() == sym)
	{
		outFile<<"Matched" << nextTok.getSymbol()<<" Lexeme "<<nextTok.getLexeme()<<endl;
		while(1)
		{
			nextTok = scanner.nextToken();		
			//newline detected			
			if(nextTok.getSymbol() == NEWLINE)
			{
				NewLine();
			}
			else if(nextTok.getSymbol() != NONAME)
				break;
			
		}
		return true;
	}
	
	//not matched returns false
	/*else
	{
		
		//this means a token is not matched a lookahead token is grabbed		
		islookAheadTok = true;
		return false;
	}
*/
}

void Parser::lookAheadToken()
{
	//this checking is done so that parser will not stuck in error. 
	//if any token is already read it will not read another token again.
	//if not read then it will grab a token 
			
	/*if(!islookAheadTok)
	{
		
		nextTok = scanner.nextToken();	
		
		islookAheadTok = true;
	}
	
	//grab the token other than newline or noname
	if(nextTok.getSymbol() == NEWLINE || nextTok.getSymbol() == NONAME || nextTok.getSymbol() == EOF)
	{		
		
		
		while(1)
		{	
			outFile<<"TUHmmmmphyy"<<nextTok.getSymbol()<<endl;			
			//newline detected
			if(nextTok.getSymbol() == NEWLINE)
			{
				NewLine();
			}
			else if(nextTok.getSymbol() != NONAME)
			{
				outFile<<"YUHmmmmphyy"<<nextTok.getSymbol()<<endl;				
				break;
			}	
			nextTok = scanner.nextToken();
			
		}
		
	}
	*/
}

//new line counter
void Parser::NewLine()
{
	lineNo++;
	outFile<<"Line No: "<<lineNo<<endl;
}

//Syntex Error recovery
// when any error occured corresponding error msg is displayed and 
// we try find the next possible symbol (stop symbol) that can occur
// after the error. For different kinds of terminal symbol stop 
// symbols are different. The different sets of stop symbols finding
// is done in this switch cases  


void Parser::ErrorCount()
{	
	errorCount++;
	if(errorCount >= MAXERRORS)
	{
		cerr<<"Too many errors. Bailing out!!\n";
		outFile<<"Too many errors. Bailed out!!";
		srcFile.close();
		outFile.close();
		exit(0);
	}
	
}	
void Parser::done()
{
	cout<<endl<<"<<<Parsing Done>>>"<<endl;
	cout<<"The methods called for nonterminals are showed in ParseOutFile "<<endl;
	outFile<<"Total no of lines: "<<lineNo<<endl;
	srcFile.close();
	outFile.close();
}

bool Parser::in(vector<Symbol> set)
{
	outFile<<"Was There??"<<endl;
	for(int i = 0; i < set.size(); i++)
	{
		
		if(nextTok.getSymbol() == set.at(i))
		{
			outFile<<nextTok.getLexeme()<<endl;		
			return true;
		}
	}
	
	return false;
}


//+ operator overloading
/*vector<Symbol> operator+(vector<Symbol> set1, vector<Symbol> set2)
{
	vector<Symbol> mergedSet;
	mergedSet.reserve(set1.size() + set2.size());
	mergedSet.insert(mergedSet.end(), set1.begin(), set1.end());
	mergedSet.insert(mergedSet.end(), set2.begin(), set2.end());

	return mergedSet;
}
*/
/*vector<Symbol> operator+(vector<Symbol> stops, Symbol sym)
{
	stops.push_back(sym);
	cout<<"Ti amor!"<<endl;
	
	return stops;
	//stops = vector<Symbol>(sym, sy + sizeof(der1) / sizeof(der1[0]) );
}*/



//write error messages to output file	
//void Parser::error(string text)
//{
	
//}	

